<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>EvoShot Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            margin-bottom: 15px;
        }
        .controls {
            margin-bottom: 15px;
        }
        button {
            background: #4a00e0;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #6a1be0; }
        button:disabled { background: #555; }
        input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            margin: 5px;
        }
        #canvas {
            background: #0f0f23;
            border-radius: 8px;
            display: block;
            width: calc(100vw - 40px);
            height: calc(100vh - 140px);
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ® EvoShot Test Client</h1>
    
    <div class="controls">
        <input type="text" id="playerName" placeholder="í”Œë ˆì´ì–´ ì´ë¦„" value="TestPlayer">
        <button id="connectBtn" onclick="connect()">Connect</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
    
    <canvas id="canvas"></canvas>

    <script>
        const SERVER_HOST = window.location.hostname;
        const SERVER_PORT = 8080;
        const WS_PATH = '/ws';

        let ws = null;
        let playerId = null;
        let players = {};
        let bullets = [];
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            console.log(`[${type}] [${time}] ${message}`);
        }

        function connect() {
            const name = document.getElementById('playerName').value || 'Player';
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${SERVER_HOST}:${SERVER_PORT}${WS_PATH}`);

            ws.onopen = () => {
                log('WebSocket ì—°ê²°ë¨', 'info');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                
                // Connect ë©”ì‹œì§€ ì „ì†¡
                send({ type: 'connect', playerName: name });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onclose = () => {
                log('WebSocket ì—°ê²° ì¢…ë£Œ', 'error');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                ws = null;
                playerId = null;
            };

            ws.onerror = (error) => {
                log('WebSocket ì—ëŸ¬: ' + error, 'error');
            };
        }

        function disconnect() {
            if (ws) ws.close();
        }

        function send(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                log('SENT: ' + JSON.stringify(message), 'sent');
            }
        }

        function handleMessage(message) {
            // game_stateëŠ” ë¡œê·¸ ìƒëžµ (60fpsë¡œ ì˜¤ê¸° ë•Œë¬¸)
            if (message.type !== 'game_state') {
                log('RECV: ' + JSON.stringify(message), 'received');
            }

            switch (message.type) {
                case 'connected':
                    playerId = message.playerId;
                    players = {};
                    message.players.forEach(p => players[p.id] = p);
                    log(`ì ‘ì† ì™„ë£Œ! PlayerId: ${playerId}, í˜„ìž¬ ${message.players.length}ëª…`, 'info');
                    break;

                case 'player_join':
                    players[message.player.id] = message.player;
                    log(`${message.player.name} ìž…ìž¥`, 'info');
                    break;

                case 'player_leave':
                    delete players[message.playerId];
                    log(`${message.playerId} í‡´ìž¥`, 'info');
                    break;

                case 'game_state':
                    message.players.forEach(p => players[p.id] = p);
                    bullets = message.bullet || [];
                    break;

                case 'pong':
                    log(`Pong received (latency: ${Date.now() - message.timestamp}ms)`, 'info');
                    break;

                case 'player_dead':
                    log(`ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.`, 'error');
                    alert('ðŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.');
                    playerId = null;
                    players = {};
                    bullets = [];
                    break;
            }

            render();
        }

        function render() {
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ì´ì•Œ ë Œë”ë§
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
            });

            Object.values(players).forEach(player => {
                // í”Œë ˆì´ì–´ ì›
                ctx.beginPath();
                ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = player.id === playerId ? '#00ff88' : '#ff6b6b';
                ctx.fill();

                // ì´ë¦„
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, player.x, player.y - 30);
            });
        }

        // ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ ìž…ë ¥ ì „ì†¡ (throttle: 16ms = 60fps)
        let lastMouseX = 0;
        let lastMouseY = 0;
        let lastSendTime = 0;
        const SEND_INTERVAL = 16; // 16ms = ì•½ 60fps

        function sendPlayerInput(shoot = false) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'player_input',
                    mouseX: lastMouseX,
                    mouseY: lastMouseY,
                    shoot: shoot
                }));
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            if (!ws || !playerId) return;
            
            const rect = canvas.getBoundingClientRect();
            lastMouseX = e.clientX - rect.left;
            lastMouseY = e.clientY - rect.top;

            const now = Date.now();
            if (now - lastSendTime >= SEND_INTERVAL) {
                lastSendTime = now;
                sendPlayerInput(false);
            }
        });

        // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ì´ì•Œ ë°œì‚¬
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!ws || !playerId) return;
            
            const rect = canvas.getBoundingClientRect();
            lastMouseX = e.clientX - rect.left;
            lastMouseY = e.clientY - rect.top;

            sendPlayerInput(true);
        });

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë°©ì§€
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Ping í…ŒìŠ¤íŠ¸
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                send({ type: 'ping', timestamp: Date.now() });
            }
        }, 5000);

        render();
    </script>
</body>
</html>

