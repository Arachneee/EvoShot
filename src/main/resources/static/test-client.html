<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>EvoShot Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            margin-bottom: 15px;
        }
        .controls {
            margin-bottom: 15px;
        }
        button {
            background: #4a00e0;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #6a1be0; }
        button:disabled { background: #555; }
        input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            margin: 5px;
        }
        #canvas {
            background: #0f0f23;
            border-radius: 8px;
            display: block;
            width: calc(100vw - 40px);
            height: calc(100vh - 140px);
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ® EvoShot Test Client</h1>
    
    <div class="controls">
        <input type="text" id="playerName" placeholder="í”Œë ˆì´ì–´ ì´ë¦„" value="TestPlayer">
        <button id="connectBtn" onclick="connect()">Connect</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
    
    <canvas id="canvas"></canvas>

    <script>
        const SERVER_HOST = window.location.hostname;
        const SERVER_PORT = 8080;
        const WS_PATH = '/ws';

        const WORLD_WIDTH = 1600;
        const WORLD_HEIGHT = 900;

        let ws = null;
        let playerId = null;
        let players = {};
        let bullets = [];
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function gameToCanvas(gameX, gameY) {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;
            return { x: gameX * scaleX, y: gameY * scaleY };
        }

        function canvasToGame(canvasX, canvasY) {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;
            return { x: canvasX / scaleX, y: canvasY / scaleY };
        }

        function getScale() {
            return Math.min(canvas.width / WORLD_WIDTH, canvas.height / WORLD_HEIGHT);
        }

        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            console.log(`[${type}] [${time}] ${message}`);
        }

        function connect() {
            const name = document.getElementById('playerName').value || 'Player';
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${SERVER_HOST}:${SERVER_PORT}${WS_PATH}`);

            ws.onopen = () => {
                log('WebSocket ì—°ê²°ë¨', 'info');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                
                // Connect ë©”ì‹œì§€ ì „ì†¡
                send({ type: 'connect', playerName: name });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onclose = () => {
                log('WebSocket ì—°ê²° ì¢…ë£Œ', 'error');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                ws = null;
                playerId = null;
            };

            ws.onerror = (error) => {
                log('WebSocket ì—ëŸ¬: ' + error, 'error');
            };
        }

        function disconnect() {
            if (ws) ws.close();
        }

        function send(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                log('SENT: ' + JSON.stringify(message), 'sent');
            }
        }

        function handleMessage(message) {
            // game_stateëŠ” ë¡œê·¸ ìƒëžµ (60fpsë¡œ ì˜¤ê¸° ë•Œë¬¸)
            if (message.type !== 'game_state') {
                log('RECV: ' + JSON.stringify(message), 'received');
            }

            switch (message.type) {
                case 'connected':
                    playerId = message.playerId;
                    players = {};
                    message.players.forEach(p => players[p.id] = p);
                    log(`ì ‘ì† ì™„ë£Œ! PlayerId: ${playerId}, í˜„ìž¬ ${message.players.length}ëª…`, 'info');
                    break;

                case 'player_join':
                    players[message.player.id] = message.player;
                    log(`${message.player.name} ìž…ìž¥`, 'info');
                    break;

                case 'player_leave':
                    delete players[message.playerId];
                    log(`${message.playerId} í‡´ìž¥`, 'info');
                    break;

                case 'game_state':
                    message.players.forEach(p => players[p.id] = p);
                    bullets = message.bullet || [];
                    break;

                case 'pong':
                    log(`Pong received (latency: ${Date.now() - message.timestamp}ms)`, 'info');
                    break;

                case 'player_dead':
                    log(`ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.`, 'error');
                    alert('ðŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.');
                    playerId = null;
                    players = {};
                    bullets = [];
                    break;
            }

            render();
        }

        function render() {
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const scale = getScale();

            // ë°”ë‹¥ ê·¸ë¦¬ê¸°
            const groundY = gameToCanvas(0, 880).y;
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // ì´ì•Œ ë Œë”ë§
            bullets.forEach(bullet => {
                const pos = gameToCanvas(bullet.x, bullet.y);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5 * scale, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
            });

            Object.values(players).forEach(player => {
                const pos = gameToCanvas(player.x, player.y);
                const radius = 20 * scale;

                // í”Œë ˆì´ì–´ ì›
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = player.id === playerId ? '#00ff88' : '#ff6b6b';
                ctx.fill();

                // ì´ë¦„
                ctx.fillStyle = '#fff';
                ctx.font = `${12 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(player.name, pos.x, pos.y - radius - 10 * scale);
            });
        }

        let lastMouseX = 0;
        let lastMouseY = 0;
        const keysPressed = {};

        function sendPlayerInput(shoot = false) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                let dx = 0;
                
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) dx -= 1;
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) dx += 1;

                const jump = keysPressed['KeyW'] || keysPressed['ArrowUp'] || keysPressed['Space'];

                ws.send(JSON.stringify({
                    type: 'player_input',
                    dx: dx,
                    jump: jump,
                    mouseX: lastMouseX,
                    mouseY: lastMouseY,
                    shoot: shoot
                }));
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!ws || !playerId) return;
            keysPressed[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            delete keysPressed[e.code];
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!ws || !playerId) return;
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
            const gamePos = canvasToGame(canvasX, canvasY);
            lastMouseX = gamePos.x;
            lastMouseY = gamePos.y;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!ws || !playerId) return;
            
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
            const gamePos = canvasToGame(canvasX, canvasY);
            lastMouseX = gamePos.x;
            lastMouseY = gamePos.y;

            sendPlayerInput(true);
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN && playerId) {
                sendPlayerInput(false);
            }
        }, 16);

        // Ping í…ŒìŠ¤íŠ¸
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                send({ type: 'ping', timestamp: Date.now() });
            }
        }, 5000);

        render();
    </script>
</body>
</html>

