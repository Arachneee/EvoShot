<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>EvoShot Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            margin-bottom: 15px;
        }
        .controls {
            margin-bottom: 15px;
        }
        button {
            background: #4a00e0;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #6a1be0; }
        button:disabled { background: #555; }
        input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            margin: 5px;
        }
        #canvas {
            background: #0f0f23;
            border-radius: 8px;
            display: block;
            width: calc(100vw - 40px);
            height: calc(100vh - 140px);
            user-select: none;
            -webkit-user-select: none;
            outline: none;
        }
        #canvas.playing {
            cursor: none;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ® EvoShot Test Client</h1>
    
    <div class="controls">
        <input type="text" id="playerName" placeholder="í”Œë ˆì´ì–´ ì´ë¦„" value="TestPlayer">
        <button id="connectBtn" onclick="connect()">Connect</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
    
    <canvas id="canvas" tabindex="0"></canvas>

    <script>
        const SERVER_HOST = window.location.hostname;
        const SERVER_PORT = 8080;
        const WS_PATH = '/ws';

        const WORLD_WIDTH = 1600;
        const WORLD_HEIGHT = 900;

        let ws = null;
        let playerId = null;
        let players = {};
        let bullets = [];
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function gameToCanvas(gameX, gameY) {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;
            return { x: gameX * scaleX, y: gameY * scaleY };
        }

        function canvasToGame(canvasX, canvasY) {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;
            return { x: canvasX / scaleX, y: canvasY / scaleY };
        }

        function getScale() {
            return Math.min(canvas.width / WORLD_WIDTH, canvas.height / WORLD_HEIGHT);
        }

        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            console.log(`[${type}] [${time}] ${message}`);
        }

        function connect() {
            const name = document.getElementById('playerName').value || 'Player';
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${SERVER_HOST}:${SERVER_PORT}${WS_PATH}`);

            ws.onopen = () => {
                log('WebSocket ì—°ê²°ë¨', 'info');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                
                // Connect ë©”ì‹œì§€ ì „ì†¡
                send({ type: 'connect', playerName: name });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onclose = () => {
                log('WebSocket ì—°ê²° ì¢…ë£Œ', 'error');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                canvas.classList.remove('playing');
                ws = null;
                playerId = null;
            };

            ws.onerror = (error) => {
                log('WebSocket ì—ëŸ¬: ' + error, 'error');
            };
        }

        function disconnect() {
            if (ws) ws.close();
        }

        function send(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                log('SENT: ' + JSON.stringify(message), 'sent');
            }
        }

        function handleMessage(message) {
            // game_stateëŠ” ë¡œê·¸ ìƒëžµ (60fpsë¡œ ì˜¤ê¸° ë•Œë¬¸)
            if (message.type !== 'game_state') {
                log('RECV: ' + JSON.stringify(message), 'received');
            }

            switch (message.type) {
                case 'connected':
                    playerId = message.playerId;
                    players = {};
                    message.players.forEach(p => players[p.id] = p);
                    canvas.classList.add('playing');
                    canvas.focus();
                    log(`ì ‘ì† ì™„ë£Œ! PlayerId: ${playerId}, í˜„ìž¬ ${message.players.length}ëª…`, 'info');
                    break;

                case 'player_join':
                    players[message.player.id] = message.player;
                    log(`${message.player.name} ìž…ìž¥`, 'info');
                    break;

                case 'player_leave':
                    delete players[message.playerId];
                    log(`${message.playerId} í‡´ìž¥`, 'info');
                    break;

                case 'game_state':
                    message.players.forEach(p => players[p.id] = p);
                    bullets = message.bullet || [];
                    break;

                case 'pong':
                    log(`Pong received (latency: ${Date.now() - message.timestamp}ms)`, 'info');
                    break;

                case 'player_dead':
                    log(`ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.`, 'error');
                    alert('ðŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”.');
                    canvas.classList.remove('playing');
                    playerId = null;
                    players = {};
                    bullets = [];
                    break;
            }

            render();
        }

        function render() {
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const scale = getScale();

            // ë°”ë‹¥ ê·¸ë¦¬ê¸°
            const groundY = gameToCanvas(0, 880).y;
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // ì´ì•Œ ë Œë”ë§
            bullets.forEach(bullet => {
                const pos = gameToCanvas(bullet.x, bullet.y);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5 * scale, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
            });

            Object.values(players).forEach(player => {
                const pos = gameToCanvas(player.x, player.y);
                const radius = 20 * scale;

                // í”Œë ˆì´ì–´ ì›
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = player.id === playerId ? '#00ff88' : '#ff6b6b';
                ctx.fill();

                // ì²´ë ¥ë°”
                const maxHp = 10;
                const hp = player.hp ?? maxHp;
                const hpBarWidth = 40 * scale;
                const hpBarHeight = 6 * scale;
                const hpBarX = pos.x - hpBarWidth / 2;
                const hpBarY = pos.y - radius - 20 * scale;

                // ì²´ë ¥ë°” ë°°ê²½ (ê²€ì€ìƒ‰)
                ctx.fillStyle = '#222';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                // ì²´ë ¥ë°” í…Œë‘ë¦¬
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                // ì²´ë ¥ë°” ì±„ìš°ê¸°
                const hpRatio = hp / maxHp;
                let hpColor;
                if (hpRatio > 0.6) {
                    hpColor = '#00ff88';
                } else if (hpRatio > 0.3) {
                    hpColor = '#ffcc00';
                } else {
                    hpColor = '#ff4444';
                }
                ctx.fillStyle = hpColor;
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);

                // ì´ë¦„
                ctx.fillStyle = '#fff';
                ctx.font = `${12 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(player.name, pos.x, pos.y - radius - 26 * scale);
            });

            // ì—ìž„ (í¬ë¡œìŠ¤í—¤ì–´) ë Œë”ë§ - ì—°ê²°ëœ ìƒíƒœì—ì„œë§Œ í‘œì‹œ
            if (playerId && (canvasMouseX > 0 || canvasMouseY > 0)) {
                const aimSize = 12;
                const aimGap = 4;
                const aimThickness = 2;

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = aimThickness;
                ctx.lineCap = 'round';

                // ìƒë‹¨ ì„ 
                ctx.beginPath();
                ctx.moveTo(canvasMouseX, canvasMouseY - aimGap);
                ctx.lineTo(canvasMouseX, canvasMouseY - aimSize);
                ctx.stroke();

                // í•˜ë‹¨ ì„ 
                ctx.beginPath();
                ctx.moveTo(canvasMouseX, canvasMouseY + aimGap);
                ctx.lineTo(canvasMouseX, canvasMouseY + aimSize);
                ctx.stroke();

                // ì¢Œì¸¡ ì„ 
                ctx.beginPath();
                ctx.moveTo(canvasMouseX - aimGap, canvasMouseY);
                ctx.lineTo(canvasMouseX - aimSize, canvasMouseY);
                ctx.stroke();

                // ìš°ì¸¡ ì„ 
                ctx.beginPath();
                ctx.moveTo(canvasMouseX + aimGap, canvasMouseY);
                ctx.lineTo(canvasMouseX + aimSize, canvasMouseY);
                ctx.stroke();

                // ì¤‘ì•™ ì 
                ctx.beginPath();
                ctx.arc(canvasMouseX, canvasMouseY, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#00ffff';
                ctx.fill();
            }
        }

        let lastMouseX = 0;
        let lastMouseY = 0;
        let canvasMouseX = 0;
        let canvasMouseY = 0;
        const keysPressed = {};

        function sendPlayerInput(shoot = false) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                let dx = 0;
                
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) dx -= 1;
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) dx += 1;

                const jump = keysPressed['KeyW'] || keysPressed['ArrowUp'] || keysPressed['Space'];

                ws.send(JSON.stringify({
                    type: 'player_input',
                    dx: dx,
                    jump: jump,
                    mouseX: lastMouseX,
                    mouseY: lastMouseY,
                    shoot: shoot
                }));
            }
        }

        canvas.addEventListener('keydown', (e) => {
            if (!ws || !playerId) return;
            e.preventDefault();
            keysPressed[e.code] = true;
        });

        canvas.addEventListener('keyup', (e) => {
            delete keysPressed[e.code];
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
            canvasMouseX = canvasX;
            canvasMouseY = canvasY;
            const gamePos = canvasToGame(canvasX, canvasY);
            lastMouseX = gamePos.x;
            lastMouseY = gamePos.y;
            render();
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!ws || !playerId) return;
            
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
            const gamePos = canvasToGame(canvasX, canvasY);
            lastMouseX = gamePos.x;
            lastMouseY = gamePos.y;

            sendPlayerInput(true);
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN && playerId) {
                sendPlayerInput(false);
            }
        }, 16);

        // Ping í…ŒìŠ¤íŠ¸
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                send({ type: 'ping', timestamp: Date.now() });
            }
        }, 5000);

        render();
    </script>
</body>
</html>

